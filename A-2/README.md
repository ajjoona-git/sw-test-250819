# 📝 A형 2번 문제. 면접

## 📖 문제 설명

[유사한 문제](https://codeforces.com/problemset/problem/338/a)

총 N개의 문항 중 M개를 맞히고, 얻을 수 있는 최소 점수를 구하는 문제입니다. 점수 계산 규칙은 다음과 같습니다.

- 점수와 연속 정답 카운터는 0에서 시작합니다.
- 문제를 맞히면 점수가 1점씩 오르고, 연속 정답 카운터도 1씩 증가합니다.
- 문제를 틀리면 점수는 변동 없고, 연속 정답 카운터는 0으로 초기화됩니다.
- 연속 정답 카운터가 K에 도달하면, 다음과 같은 보너스를 받습니다:
  - 현재 맞힌 문제에 대한 점수 1점을 추가로 받습니다.

  - 전체 점수가 2배가 됩니다.

  - 연속 정답 카운터는 0으로 초기화됩니다.

주어진 N, M, K 조건에서 얻을 수 있는 최소 점수를 계산하여 출력해야 합니다.

## ⌨️ 입력 형식
첫 줄에 테스트 케이스의 수 T가 주어집니다.
각 테스트 케이스는 한 줄에 N, M, K 세 정수가 주어집니다.

- `N`: 전체 문항 수

- `M`: 맞힌 문항 수

- `K`: 연속 정답 보너스 기준

## ⏳ 시간 제한
Python 기준 6초 이내

---

## 💡 접근 방식

### 1. 사용 알고리즘
* **구현(Implementation)**
* **그리디(Greedy)** 알고리즘
* **시뮬레이션(Simulation)**

### 2. 문제 풀이 과정
1.  먼저 주어진 문제의 조건(총 문제 수 `N`, 맞힌 문제 수 `M`, 보너스 카운터 `K`)을 바탕으로 최소 점수를 얻는 방법을 찾습니다. 이 문제의 최소 점수 전략은 **보너스를 가능한 한 빨리, 몰아서 받는 것**입니다.
2.  틀린 문제를 칸막이로 사용하여 보너스를 피할 수 있는 최대 문제 수(`safe_capacity`)를 계산합니다. 이는 `(틀린 문제 수 + 1) * (K - 1)`로 구할 수 있습니다.
3.  만약 맞힌 문제 수(`M`)가 `safe_capacity`보다 작거나 같다면, 보너스를 받지 않고 모든 문제를 1점씩 획득할 수 있으므로, 최종 점수는 `M`이 됩니다.
4.  만약 `M`이 `safe_capacity`를 초과한다면, 보너스를 받는 것이 불가피합니다.
    * 보너스를 받아야 하는 문제 수(`must_bonus_problems`)를 `M - safe_capacity`로 계산합니다.
    * 이 문제 수로 만들 수 있는 최소 보너스 묶음의 개수(`num_bonus_groups`)를 계산합니다.
5.  가장 낮은 점수를 받기 위해, 이 보너스 묶음을 초반에 모두 해결했다고 가정하고 점수를 시뮬레이션합니다.
    * 보너스 묶음으로 얻는 점수는 `2 * K * (2 ** num_bonus_groups - 1)` 공식으로 계산합니다.
    * 보너스 묶음을 만들고도 남은 문제들은 보너스 없이 1점씩만 획득합니다.
6.  최종 점수는 보너스 점수와 남은 문제의 점수를 합하여 계산합니다.

---

## 💻 코드
* [solution](sol_simulation.py)
* [재귀로 풀어본 코드(FAIL)](try_recursive.py)
* [부분집합으로 풀어본 코드(FAIL)](try_powerset.py)
* [for문으로 풀어본 코드(FAIL)](try_for.py)

